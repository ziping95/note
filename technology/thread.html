<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>多线程 | Ziping</title>
    <meta name="description" content="note">
    <link rel="icon" href="/note/note/favicon.ico">
    
    <link rel="preload" href="/note/assets/css/0.styles.a9e67ab9.css" as="style"><link rel="preload" href="/note/assets/js/app.1a90efae.js" as="script"><link rel="preload" href="/note/assets/js/2.2500f49d.js" as="script"><link rel="preload" href="/note/assets/js/20.d64a5959.js" as="script"><link rel="prefetch" href="/note/assets/js/10.9a223367.js"><link rel="prefetch" href="/note/assets/js/11.48953735.js"><link rel="prefetch" href="/note/assets/js/12.6bbe1fae.js"><link rel="prefetch" href="/note/assets/js/13.d13eced0.js"><link rel="prefetch" href="/note/assets/js/14.ce688660.js"><link rel="prefetch" href="/note/assets/js/15.9abd9958.js"><link rel="prefetch" href="/note/assets/js/16.6f056f12.js"><link rel="prefetch" href="/note/assets/js/17.3667f3b7.js"><link rel="prefetch" href="/note/assets/js/18.c94df683.js"><link rel="prefetch" href="/note/assets/js/19.66803cab.js"><link rel="prefetch" href="/note/assets/js/21.5e22e6e5.js"><link rel="prefetch" href="/note/assets/js/22.7c1a1123.js"><link rel="prefetch" href="/note/assets/js/3.016f2f39.js"><link rel="prefetch" href="/note/assets/js/4.1bb14f0f.js"><link rel="prefetch" href="/note/assets/js/5.96359bb1.js"><link rel="prefetch" href="/note/assets/js/6.7e64918c.js"><link rel="prefetch" href="/note/assets/js/7.d3dcc629.js"><link rel="prefetch" href="/note/assets/js/8.826d4738.js"><link rel="prefetch" href="/note/assets/js/9.79694894.js">
    <link rel="stylesheet" href="/note/assets/css/0.styles.a9e67ab9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note/" class="home-link router-link-active"><!----> <span class="site-name">Ziping</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/technology/" class="nav-link router-link-active">技术沉淀</a></div><div class="nav-item"><a href="/note/linux/" class="nav-link">日常命令</a></div><div class="nav-item"><a href="/note/ans/" class="nav-link">问题总结</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://www.sojson.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Json格式化
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://tool.lu/regex/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  正则
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue官网
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://tool.lu/timestamp/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  时间戳转换
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Unicode编码转换
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://cli.im/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  二维码生成
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://alibaba.github.io/arthas/install-detail.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Arthas文档
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.iamwawa.cn/daxiaoxie.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  大小写转换
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://www.jq22.com/textDifference" target="_blank" rel="noopener noreferrer" class="nav-link external">
  文本差异对比
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/technology/" class="nav-link router-link-active">技术沉淀</a></div><div class="nav-item"><a href="/note/linux/" class="nav-link">日常命令</a></div><div class="nav-item"><a href="/note/ans/" class="nav-link">问题总结</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具" class="dropdown-title"><span class="title">工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://www.sojson.com/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Json格式化
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://tool.lu/regex/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  正则
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://element.eleme.cn/#/zh-CN" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Vue官网
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://tool.lu/timestamp/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  时间戳转换
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://tool.chinaz.com/tools/unicode.aspx" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Unicode编码转换
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://cli.im/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  二维码生成
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://alibaba.github.io/arthas/install-detail.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Arthas文档
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://www.iamwawa.cn/daxiaoxie.html" target="_blank" rel="noopener noreferrer" class="nav-link external">
  大小写转换
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="http://www.jq22.com/textDifference" target="_blank" rel="noopener noreferrer" class="nav-link external">
  文本差异对比
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/technology/" class="sidebar-link">设计模式</a></li><li><a href="/note/technology/component.html" class="sidebar-link">监听器、过滤器、拦截器</a></li><li><a href="/note/technology/thread.html" class="active sidebar-link">多线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/technology/thread.html#锁" class="sidebar-link">锁</a></li><li class="sidebar-sub-header"><a href="/note/technology/thread.html#线程通信" class="sidebar-link">线程通信</a></li></ul></li><li><a href="/note/technology/collection.html" class="sidebar-link">集合</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>源码阅读</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/technology/springMVC.html" class="sidebar-link">SpringMVC</a></li><li><a href="/note/technology/SpringBoot.html" class="sidebar-link">SpringBoot</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端技术</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/technology/css.html" class="sidebar-link">CSS样式</a></li><li><a href="/note/technology/vue.html" class="sidebar-link">Vue</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>代码整理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/technology/httpClient.html" class="sidebar-link">HttpClient常见请求与传参方式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="多线程"><a href="#多线程" class="header-anchor">#</a> 多线程</h1> <h3 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h3> <hr> <ul><li><a href="#%E9%94%81">锁</a> <ul><li><a href="#synchronized%EF%BC%88%E5%90%8C%E6%AD%A5%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89">同步关键字（synchronized）</a></li> <li><a href="#reentrantlock%EF%BC%88%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%EF%BC%89">可重入锁（reentrantlock）</a></li> <li><a href="#readwritelock%EF%BC%88%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%89">读写锁（readwritelock）</a></li> <li><a href="#semaphore%EF%BC%88%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%89">信号量（Semaphore）</a></li> <li><a href="#countdownlatch%EF%BC%88%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%89">计数器（CountDownLatch）</a></li> <li><a href="#cyclicbarrier%EF%BC%88%E6%A0%85%E6%A0%8F%EF%BC%89">栅栏（CyclicBarrier）</a></li></ul></li> <li><a href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1">线程通信</a> <ul><li><a href="#stop%EF%BC%88%E5%BC%BA%E5%88%B6%E7%BB%88%E6%AD%A2%E2%80%94%E8%A2%AB%E5%BC%83%E7%94%A8%EF%BC%89">stop（强制终止—被弃用）</a></li> <li><a href="#suspend%E5%92%8Cresume%EF%BC%88%E8%A2%AB%E5%BC%83%E7%94%A8%EF%BC%89">suspend和resume（被弃用）</a></li> <li><a href="#wait%E5%92%8Cnotify">wait和notify</a></li> <li><a href="#park%E5%92%8Cunpark">park和unpark</a></li></ul></li></ul> <h2 id="锁"><a href="#锁" class="header-anchor">#</a> 锁</h2> <p>由于多个线程对同一个对象进行写操作，其必然出现资源争抢，引发线程安全问题，而锁就是为了解决这种问题而诞生的，java中如下几种锁</p> <blockquote><ul><li>自旋锁：为了不放弃CPU执行事件，循环使用<code>CAS</code>技术对数据更新，直至成功，使用<code>while(true)</code>方式循环<code>CAS</code>操作为自旋锁的典型实现</li> <li>悲观锁：在执行前假定会发生冲突，所以从读取数据开始就对行为上锁，参考<code>synchronized</code>关键字</li> <li>乐观锁：提出了版本的概念，在读取数据时，会将当前数据版本号一并读出来，每次写时候会对版本进行修改，其他线程写的时候，会先判断当前版本号和读取时是否一致，一致才会进行写入</li> <li>独享锁（写）：给资源加上写锁，线程可以修改资源，其他线程不能再加锁，<code>synchronized</code>也属于这种</li> <li>共享锁（读）：给资源加上读锁，其他线程也只能加读锁，不能加写锁</li> <li>可重入锁、不可重入锁：线程拿到一把锁后，可以自由进入同一把锁所同步的其他代码，<code>synchronized</code>属于可重入锁</li> <li>公平锁、非公平锁：争抢锁的顺序，按照先来后到的顺序</li></ul></blockquote> <p>Java中有几种重要的锁实现方式：<code>synchronized</code>，<code>ReentrantLock</code>，<code>ReentrantReadWriteLock</code></p> <h3 id="synchronized（同步关键字）"><a href="#synchronized（同步关键字）" class="header-anchor">#</a> synchronized（同步关键字）</h3> <p>这属于java中最基本的线程通信机制，基于对象监视器实现，上面介绍过属于可重入，独享，悲观锁类型，在使用时，可用于方法（静态/非静态），同步代码块，同时由于<code>Happens-Before</code>规则的存在，<code>synchronized</code>也可以用来保证可见性</p> <div class="custom-block warning"><p class="custom-block-title">锁失效问题</p> <p><code>synchronized</code>在非静态方法上，监视器所监视的对象为当前对象<code>this</code>，因此如果多个线程是通过不同对象调用该方法时，同步作用失效。静态方法由于是监视类对象，因此不存在该问题</p></div> <p>在<code>synchronized</code>关键字中，有一种场景为<code>锁粗化</code>，意思为，如果一段代码被频繁调用执行，而这段代码中有两个以上的<code>synchronized</code>并且对象锁是同一个时，在<code>JIT</code>判断是否属于热点代码，若是，则会将两个锁合并为一个使用。
例如下代码</p> <div class="custom-block tip"><p class="custom-block-title">Java代码执行过程</p> <ol><li>源代码经javac编译成字节码，class文件</li> <li>程序字节码经过<code>JIT</code>环境变量进行判断，是否属于“热点代码”（多次调用的方法，或循环等），若是，走JIT编译为具体硬件处理器（如sparc、intel）机器码，若不是，则直接由解释器解释执行</li> <li>操作系统及类库调用</li></ol></div> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果<code>JIT</code>判断出以上代码在项目中存在多次调用，会自动将以上代码优化为</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     i<span class="token operator">++</span><span class="token punctuation">;</span>
     i<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还有一种情况为<code>锁消除</code>，同样属于<code>JIT</code>优化后的结果，我们都知道<code>StringBuffer</code>是线程安全的，其<code>append</code>方式就是使用了<code>synchronized</code>修饰</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">StringBuffer</span> stringBuffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stringBuffer<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stringBuffer<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stringBuffer<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;3&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由于这段代码使用的是局部变量，不会存在线程安全问题，因此<code>JIT</code>会在编译期将其内部的<code>synchronized</code>关键字消除</p> <p><code>synchronized</code>实际会修改对象头中的一个标志位来表明当前对象状态，其加锁过程会经历 <strong>偏向锁--&gt;轻量级锁（CAS操作修改标志位）--&gt;重量级锁（Monitor监视器）</strong>，偏向锁可以在启动时通过参数关闭</p> <p>偏向锁，仅仅是第一次有用（实际就是无锁，因为没有出现资源争抢），只要当前对象出现过争抢资源时，就会变成轻量级锁。</p> <p>轻量级锁，通过不断的自旋判断当前对象是否有锁，若没锁，则绑定当前线程（加锁），如果有锁就会不断的自旋进行<code>CAS</code>，但自旋会消耗过多的性能，达到一定次数后，该对象会升级成重量级锁，进入阻塞</p> <h3 id="reentrantlock（可重入锁）"><a href="#reentrantlock（可重入锁）" class="header-anchor">#</a> ReentrantLock（可重入锁）</h3> <p><code>ReentrantLock</code>是<code>Lock</code>接口的一个实现类，具有独享，可重入特性，并且支持公平锁、非公平锁两种模式</p> <p>在使用时，通过<code>lock.lock()</code>加锁，通过<code>lock.unlock()</code>解锁。</p> <p>值得注意的是，在加锁的同时，会修改锁内的一个计数标志位，记录当前获取锁的次数，如果执行了两次<code>lock.lock()</code>，则对应的计数为2，且在释放锁时，也必须进行两次<code>lock.unlock()</code>解锁，否则其他线程依旧拿不到这把锁</p> <p>另外，如果线程在获取锁的时候被阻塞住了，并且我们想手动中断这个被阻塞的线程，则必须使用<code>lock.lockInterruptibly()</code>来争抢锁，否则无法中断线程</p> <p><code>ReentrantLock</code>内部通过调用<code>sync.lock()</code>方法实现，Sync继承自<code>AbstractQueuedSynchronizer</code>（抽象队列同步器简称<code>AQS</code>）类，该类体现了设计模式中的模板方法，对锁的关键步骤进行了抽象，比如加锁，解锁，将线程放入链表中，其中尝试加锁，尝试解锁由具体的子类复写实现</p> <p>在<code>JDK</code>提供多种锁的实现中，均用到了这个类，先来看一下<code>Sync</code>的子类<code>NonfairSync</code>（非公平锁）对<code>lock</code>方法的实现</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这里先尝试进行CAS操作修改锁的标志位</span>
    <span class="token comment">// 如果修改成功，则将当前线程赋予exclusiveOwnerThread属性，记录当前哪个线程获得了这把锁</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>
    <span class="token comment">// 修改失败，为了保证可重入性，会尝试获取锁</span>
        <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在<code>acquire</code>方法中做了两次尝试，其方法分别是调用复写的<code>tryAcquire()</code>方法和将当前线程放入链表并阻塞的方法<code>acquireQueued()</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>EXCLUSIVE<span class="token punctuation">)</span><span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">selfInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在<code>tryAcquire()</code>方法中调用了<code>nonfairTryAcquire()</code>方法，这个方法保证了可重入性</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">nonfairTryAcquire</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先获取当前线程</span>
    <span class="token keyword">final</span> <span class="token class-name">Thread</span> current <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果当前线程无锁，则尝试CAS操作修改标志位，成功则保存当前线程为锁持有者</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> acquires<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果这把锁已经有持有者了，则判断当前线程是否是锁的持有者。</span>
    <span class="token comment">// 如果是，则累加标志位。</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">==</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c <span class="token operator">+</span> acquires<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextc <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum lock count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setState</span><span class="token punctuation">(</span>nextc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 以上判断都不是则获取锁失败</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以看到，在重入锁的时候会对锁的标志位进行累加，这也验证了<code>lock()</code>和<code>unlock()</code>必须成对出现，否则会进入死循环</p> <p>执行完该方法后，如果没有获取到锁，则调用<code>acquireQueued()</code>尝试将当前线程放入队列中并阻塞等待</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">acquireQueued</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Node</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> interrupted <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 自旋判断链表中的前一节点是否为头节点，如果是，则再尝试获取一次锁</span>
            <span class="token comment">// 如果获取到了则返回</span>
            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head <span class="token operator">&amp;&amp;</span> <span class="token function">tryAcquire</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">setHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
                p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
                failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> interrupted<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果依旧没获取到则将线程放入当前节点并阻塞</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                interrupted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里通过<code>LockSupport.park(this)</code>方式阻塞，具体代码不展示了，下面看一下解锁<code>unlock()</code>方法是如何实现的</p> <p>在代码中可以看到，同样调用了<code>AQS</code>类中的方法，只不过解锁改为了<code>release()</code>方法，在该方法中调用了子类复写的<code>tryRelease()</code>方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryRelease</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先计算释放后的标志位</span>
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> releases<span class="token punctuation">;</span>
    <span class="token comment">// 判断解锁的进程是否是锁持有者</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token function">getExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalMonitorStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> free <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果标志位为0，说明没有任何一个线程持有这把锁了，因此将持有者属性设为null</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        free <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token function">setExclusiveOwnerThread</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 如果不是0，说明这个锁有重入的线程，因此仅仅减少一层锁，但该锁的线程持有者依旧不变</span>
    <span class="token function">setState</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> free<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>由上可知，当锁完全释放后，该方法返回一个true，程序返回到<code>release()</code>方法中继续执行，去通知后面的线程唤醒并执行</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryRelease</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> h <span class="token operator">=</span> head<span class="token punctuation">;</span>
        <span class="token comment">// 当锁释放后，判断链表中是否还有其他线程，如果有则通过unparkh唤醒下一个节点的线程</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> h<span class="token punctuation">.</span>waitStatus <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">unparkSuccessor</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>Condition</code>是<code>ReentrantLock</code>中的一个功能点，其作用是配合<code>Lock</code>使用可以达到<code>wait</code>/<code>notify</code>相同的作用，并且可以更加精确地控制唤醒某个具体线程（底层是<code>park</code>/<code>unPark</code>机制）。</p> <p>假设现在有个容器，并且有两个线程，分别是生产者线程和消费者线程，当容器里没东西的时候消费者线程则进入阻塞等待，当生产者生产完东西时，唤醒消费者线程进行消费，反之当容器满的时候生产者阻塞，当有空余位置时，消费者唤醒生产者去继续生产</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Lock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 生产者对应的条件</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Condition</span> producerCondition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 消费者对应的条件</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> <span class="token class-name">Condition</span> consumerCondition <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 消费者如果发现容器空了，则进入对应的条件阻塞</span>
consumerCondition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 生产者生产完东西放入容器后，唤醒消费者消费</span>
consumerCondition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 生产者发现容器满了，则进入对应的条件阻塞</span>
producerCondition<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 消费者消费完，通知生产者继续生产</span>
producerCondition<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意<code>await()</code>会释放锁</p> <h3 id="readwritelock（读写锁）"><a href="#readwritelock（读写锁）" class="header-anchor">#</a> ReadWriteLock（读写锁）</h3> <p><code>ReadWriteLock</code>是一个读写锁的接口，其典型实现为<code>ReentrantReadWriteLock</code>，读写锁实际是维护一对关联锁，一个只用于读操作，一个用于写操作，读锁是一个共享锁，可以由多个线程同时持有，而写锁是排他锁</p> <p>当所有的读操作完成时，才会进行加写锁操作。适用于读取比写入多的场景，例如：缓存</p> <p>在读写锁中有一个<code>锁降级</code>的概念，指把写锁降级为读锁。把持住当前拥有的写锁同时，再获取到读锁，随后释放写锁的过程。</p> <p>我们可以看到在<code>ReentrantReadWriteLock</code>中，同时维护了读锁和写锁</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/** Inner class providing readlock */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">.</span><span class="token class-name">ReadLock</span> readerLock<span class="token punctuation">;</span>
<span class="token comment">/** Inner class providing writelock */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantReadWriteLock</span><span class="token punctuation">.</span><span class="token class-name">WriteLock</span> writerLock<span class="token punctuation">;</span>
</code></pre></div><h3 id="semaphore（信号量）"><a href="#semaphore（信号量）" class="header-anchor">#</a> Semaphore（信号量）</h3> <p><code>Semaphore</code>多用来接口限流，通过给线程发放凭证来保证同一资源被访问次数，其实就是一种共享锁的一种体现，使用起来很简单</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Semaphore</span> semaphore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
semaphore<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// todo: do something</span>
semaphore<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>整体来说先<strong>获取令牌 --&gt; 执行逻辑 --&gt; 释放令牌</strong>，其中实现也和<code>AQS</code>类相关，先来看一下获取令牌的操作原理</p> <p>在调用<code>acquire()</code>方法时，实际就是调用了<code>Sync</code>类的<code>acquireSharedInterruptibly(1)</code>方法，上面我们写过，<code>Sync</code>继承自<code>AbstractQueuedSynchronizer</code>类</p> <p>在<code>acquireSharedInterruptibly</code>方法中，开始尝试获取信号量</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">acquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 尝试获取信号量，如果信号量不足时，尝试将当前线程阻塞住</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过调用子类复写的<code>tryAcquireShared</code>方法，最终调用<code>nonfairTryAcquireShared</code>方法，在该方法中先计算出来如果发放令牌后，信号量的剩余量</p> <p>如果小于0，则不进行CAS操作，并返回</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">nonfairTryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 自旋判断</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 先获取当前剩余信号量</span>
        <span class="token keyword">int</span> available <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 计算发放后的剩余信号量</span>
        <span class="token keyword">int</span> remaining <span class="token operator">=</span> available <span class="token operator">-</span> acquires<span class="token punctuation">;</span>
        <span class="token comment">// 当信号量不足或CAS操作成功时返回剩余信号量</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>remaining <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
            <span class="token function">compareAndSetState</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> remaining<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> remaining<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>代码返回<code>acquireSharedInterruptibly</code>方法继续执行，如果返回的剩余信号量小于零，则说明无信号量可用，则调用<code>doAcquireSharedInterruptibly</code>方法将当前线程阻塞住</p> <p>在这个方法中阻塞逻辑和上面独享锁的<code>acquireQueued()</code>方法逻辑相似，依旧是先判断上一个节点是否是头节点，如果是则重新尝试获取信号量，否则将当前线程加入链表中阻塞，只不过链表的节点属性变为了<code>Node.SHARED</code>（共享锁）</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doAcquireSharedInterruptibly</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Node</span> node <span class="token operator">=</span> <span class="token function">addWaiter</span><span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token punctuation">.</span>SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> failed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 获取上一个节点</span>
            <span class="token keyword">final</span> <span class="token class-name">Node</span> p <span class="token operator">=</span> node<span class="token punctuation">.</span><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 判断是否是头节点</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> head<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 重新尝试获取信号量</span>
                <span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 获取到后，将节点设置为头节点，并返回</span>
                    <span class="token function">setHeadAndPropagate</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> r<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// help GC</span>
                    failed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 如果不是头节点或者没获取到信号量，则调用下面方法进行阻塞线程</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">shouldParkAfterFailedAcquire</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> node<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                <span class="token function">parkAndCheckInterrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>failed<span class="token punctuation">)</span>
            <span class="token function">cancelAcquire</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这个方法中阻塞线程依旧采用的是<code>pack</code>/<code>unpack</code>机制，下面看一下，释放信号量是如何实现的</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">releaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 先尝试释放，如果成功则唤醒后面阻塞的线程重新获取信号量</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">tryReleaseShared</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">doReleaseShared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中在<code>tryReleaseShared()</code>方法是需要在子类中进行复写，具体实现逻辑和之前的<code>ReentrantLock</code>相似，依旧是通过判断标志位，进行<code>CAS</code>操作来实现的</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取当前信号量</span>
        <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 释放后的信号量</span>
        <span class="token keyword">int</span> next <span class="token operator">=</span> current <span class="token operator">+</span> releases<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&lt;</span> current<span class="token punctuation">)</span> <span class="token comment">// overflow</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Maximum permit count exceeded&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// CAS操作成功后返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该方法执行完后返回，<code>releaseShared</code>方法调用<code>doReleaseShared</code>来唤醒后面的线程</p> <h3 id="countdownlatch（计数器）"><a href="#countdownlatch（计数器）" class="header-anchor">#</a> CountDownLatch（计数器）</h3> <p><code>AQS</code>另一个重要应用就是在<code>CountDownLatch</code>中</p> <p>应用场景为：主线程开启了多个线程执行任务，并且主线程需要等所有子线程执行完任务后在，再继续执行后面的逻辑，可以使用如下代码</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">CountDownLatch</span> countDownLatch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CountDownLatch</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// todo: 通知子线程执行任务</span>
<span class="token comment">// 主线程 调用await方法进行阻塞，当count为0时，自行唤醒主线程</span>
countDownLatch<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 各个子线程执行完后调用countDown()方法进行减一</span>
countDownLatch<span class="token punctuation">.</span><span class="token function">countDown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>其实现原理与信号量相同，都是通过调用<code>AQS</code>中的<code>acquireSharedInterruptibly</code> / <code>releaseShared</code>方法，进行阻塞和释放</p> <p>通过<code>CountDownLatch</code>复写的<code>tryAcquireShared</code>方法，来判断当前计数是否为零</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">tryAcquireShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> acquires<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不是零的话返回-1 然后在<code>acquireSharedInterruptibly</code>方法中判断<code>tryAcquireShared</code>返回值，如果小于零则阻塞当前线程</p> <p>在子线程在调用<code>countDown()</code>时，实际做了一次释放资源的操作，这个操作同样通过一层层调用，最终调用到<code>CountDownLatch</code>复写的<code>tryReleaseShared</code>方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">tryReleaseShared</span><span class="token punctuation">(</span><span class="token keyword">int</span> releases<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 循环判断</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果为0后，返回false，可以理解为抛异常</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> nextc <span class="token operator">=</span> c<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token comment">// 通过CAS修改状态位，如果是0返回true，用于后续判断唤醒线程使用</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSetState</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> nextc<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> nextc <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>执行完以上方法后调用<code>doReleaseShared</code>唤醒主线程</p> <h3 id="cyclicbarrier（栅栏）"><a href="#cyclicbarrier（栅栏）" class="header-anchor">#</a> CyclicBarrier（栅栏）</h3> <p>这个应用场景和<code>CountDownLatch</code>相反，通常用来多个线程并发执行</p> <p>比如想要批量执行SQL，一次性执行5条SQL，那么前四个线程会将SQL缓存起来，并阻塞，当第五个线程来的时候，同时唤醒前四个线程，并执行，可以看下面的例子</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 当线程满了后，执行的回调逻辑</span>
        <span class="token class-name">Runnable</span> action <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// todo: 批量执行SQL</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;批量执行了SQL&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">CyclicBarrier</span> cyclicBarrier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Runnable</span> task <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">try</span> <span class="token punctuation">{</span>
                    <span class="token comment">// todo：将SQL缓存起来</span>
                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;生成SQL完成&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    cyclicBarrier<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> <span class="token operator">|</span> <span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>下面看下其原理实现，在调用<code>await()</code>方法后会在其内部调用一个<code>dowait()</code>方法，该方法是<code>CyclicBarrier</code>的核心逻辑，我们可以分为两部份来看</p> <p>首先看线程满了之后，执行回调的部分，在该方法内部，会先判断当前还可以阻塞的线程数，如果为0时，则开始调用<code>CyclicBarrier</code>初始化时，传入的<code>Runnable</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token operator">--</span>count<span class="token punctuation">;</span>
<span class="token comment">// 判断是否还有阻塞线程的名额</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// tripped</span>
    <span class="token keyword">boolean</span> ranAction <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">Runnable</span> command <span class="token operator">=</span> barrierCommand<span class="token punctuation">;</span>
        <span class="token comment">// 如果线程已满，则开始调用Runnable</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            command<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ranAction <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token comment">// Runnable执行完成后，唤醒当前批次阻塞的所有线程，并开始下一轮的初始化复赋值（count重新赋值）</span>
        <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ranAction<span class="token punctuation">)</span>
            <span class="token function">breakBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>唤醒当前批次所阻塞的线程操作在<code>nextGeneration</code>方法中，在这个方法中不但唤醒了线程，并且对下一轮的属性进行了赋值</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">nextGeneration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 唤醒本轮所有线程</span>
    trip<span class="token punctuation">.</span><span class="token function">signalAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 开启下一轮</span>
    count <span class="token operator">=</span> parties<span class="token punctuation">;</span>
    generation <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Generation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在<code>CyclicBarrier</code>这个类中，我们可以看到<code>trip</code>其实就是一个<code>Condition</code></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/** The lock for guarding barrier entry */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/** Condition to wait on until tripped */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Condition</span> trip <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>而<code>signalAll</code>这个接口方法是由<code>AbstractQueuedSynchronizer</code>的内部类<code>ConditionObject</code>实现的。</p> <p>同样阻塞的线程被保存到一个链表中，通过遍历链表来唤醒线程，这里的唤醒线程同样通过<code>LockSupport.unpark()</code>方式实现</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doSignalAll</span><span class="token punctuation">(</span><span class="token class-name">Node</span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lastWaiter <span class="token operator">=</span> firstWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token class-name">Node</span> next <span class="token operator">=</span> first<span class="token punctuation">.</span>nextWaiter<span class="token punctuation">;</span>
        first<span class="token punctuation">.</span>nextWaiter <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token function">transferForSignal</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>
        first <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上就是<code>CyclicBarrier</code>控制并发执行的主流程，而对于线程未满的情况，将线程阻塞住的流程，就相对简单了</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timed<span class="token punctuation">)</span>
            <span class="token comment">// 如果未指定超时时间，则使用Condition接口的await()方法将线程阻塞住</span>
            trip<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nanos <span class="token operator">&gt;</span> <span class="token number">0L</span><span class="token punctuation">)</span>
            nanos <span class="token operator">=</span> trip<span class="token punctuation">.</span><span class="token function">awaitNanos</span><span class="token punctuation">(</span>nanos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> ie<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// todo: do something</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><h2 id="线程通信"><a href="#线程通信" class="header-anchor">#</a> 线程通信</h2> <p>Java中线程之间的通信一般有<code>stop</code>、<code>suspend</code> / <code>resume</code>、<code>wait</code> / <code>notify</code>、<code>park</code> / <code>unpark</code></p> <h3 id="stop（强制终止—被弃用）"><a href="#stop（强制终止—被弃用）" class="header-anchor">#</a> Stop（强制终止—被弃用）</h3> <ul><li><code>stop()</code>是过时的，不建议使用</li> <li><code>stop()</code>是一种强制中断，并不关心当前线程状态和代码执行逻辑，一但调用，则立即终止，如果在有锁的情况下，也不会释放锁，造成死锁</li> <li><code>stop()</code>会破坏代码的原子性逻辑，因为调用时，我们并不清楚线程执行到那行逻辑，有可能会造成数据不一致</li></ul> <h3 id="suspend和resume（被弃用）"><a href="#suspend和resume（被弃用）" class="header-anchor">#</a> suspend和resume（被弃用）</h3> <p>线程通过调用<code>suspend()</code>方法阻塞，通过调用<code>resume()</code>唤醒</p> <p>需要注意的是这种方式也容易造成死锁，造成死锁的情况有两种</p> <ul><li>如果在同步代码中调用<code>suspend()</code> / <code>resume()</code>方法，线程在阻塞时并不会释放对象锁，导致无法执行<code>resume()</code></li> <li>如果调用<code>resume()</code>在<code>suspend()</code>方法之前，同样会造成死锁</li></ul> <p>例如以下两种代码，均会造成<strong>死锁</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendAndResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;开始休眠&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;即将唤醒子线程&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 由于suspend方法不会释放锁，因此代码到这里就会死锁</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        thread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>针对这种死锁的情况，推荐使用<code>wait</code> / <code>notify</code> 方式，这种方式会在阻塞时自动释放锁</p> <p>第二种<strong>死锁</strong>情况，是由于在调用<code>suspend()</code>方法前已经调用了<code>resume()</code>方法</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">suspendAndResume</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;开始休眠&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;准备调用suspend()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">suspend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;唤醒了&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;准备调用resume()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 这里由于有限调用了resume(),因此当线程一旦调用suspend()方法后，在本代码中就无法唤醒了</span>
    thread<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>针对由于这种方式引起的死锁，推荐使用<code>park</code> \ <code>unpark</code>机制阻塞线程</p> <h3 id="wait和notify"><a href="#wait和notify" class="header-anchor">#</a> wait和notify</h3> <p><code>wait</code>和<code>notify</code>方式是基于对象监视器来进行线程阻塞的，在调用<code>wait()</code>方法后，会将线程放入该对象的等待队列中，并且会主动放弃资源（锁）。当调用<code>notify()</code>方法时，会将一个线程从等待队列中拿出来，重新进行资源的争抢</p> <p>由于<code>wait</code>和<code>notify</code>会对对象头中的锁标志位进行修改，因此他们必须在同步代码块中使用。</p> <div class="custom-block tip"><p class="custom-block-title">wait和sleep的区别</p> <ol><li>所属类不同<code>wait</code>是来自<code>Object</code>类，而<code>sleep</code>来自<code>Thread</code>类</li> <li><code>wait</code>是基于对象监视器实现的，且必须在同步代码块中使用，会自动释放锁，而<code>sleep</code>可以在任意处使用，但不会释放锁</li></ol></div> <p>值得注意的是，虽然<code>wait()</code>方法会自动释放锁，但对代码的执行顺序还是有要求的，<code>notify()</code>方法必须在<code>wait()</code>后执行，否则会造成死锁，下面是<strong>死锁</strong>示例</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">waitAndNotify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
    <span class="token comment">// 这种方式对唤醒的调用顺序有要求</span>
    <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;线程开始执行run方法&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;子线程开始休眠&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 由于主线程先执行了notify()方法，因此在这里会造成死锁</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;子线程被唤醒&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;主线程唤醒子线程&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">伪唤醒</p> <p>代码中不应该用if判断是否应该进入等待状态，原因是处于等待状态的线程可能会因为CPU、操作系统调度等底层原因造成伪唤醒。</p> <p>因此官方建议在循环中检查等待条件，例如
<code>java while(判断等待条件) { // todo: 线程等待 }</code></p></div> <p>上面的代码展示了<code>wait</code>和<code>notify</code>方式由于调用顺序问题造成死锁的情况，为了弥补这种问题，<code>JDK</code>提供了另外一种机制<code>park</code> \ <code>unpark</code></p> <h3 id="park和unpark"><a href="#park和unpark" class="header-anchor">#</a> park和unpark</h3></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/technology/component.html" class="prev">监听器、过滤器、拦截器</a></span> <span class="next"><a href="/note/technology/collection.html">集合</a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/note/assets/js/app.1a90efae.js" defer></script><script src="/note/assets/js/2.2500f49d.js" defer></script><script src="/note/assets/js/20.d64a5959.js" defer></script>
  </body>
</html>
