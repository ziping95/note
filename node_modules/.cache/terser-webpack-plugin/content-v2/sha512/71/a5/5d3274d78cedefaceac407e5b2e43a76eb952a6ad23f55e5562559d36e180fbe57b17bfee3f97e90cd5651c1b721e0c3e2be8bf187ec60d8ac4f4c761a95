{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{214:function(e,t,v){e.exports=v.p+\"assets/img/DispatchServlet-extends.c25d983a.png\"},215:function(e,t,v){e.exports=v.p+\"assets/img/HttpServlet-Service.c577ee7d.png\"},216:function(e,t,v){e.exports=v.p+\"assets/img/FrameworkServlet-Service.3f80d779.png\"},217:function(e,t,v){e.exports=v.p+\"assets/img/HttpServlet-Service-1.cfc1dff3.png\"},218:function(e,t,v){e.exports=v.p+\"assets/img/FrameworkServlet-doGet.6a930fc8.png\"},219:function(e,t,v){e.exports=v.p+\"assets/img/FrameworkServlet-processRequest.67391d1b.png\"},220:function(e,t,v){e.exports=v.p+\"assets/img/DispatcherServlet-doDisPatch.48b5a394.png\"},221:function(e,t,v){e.exports=v.p+\"assets/img/HandlerMapping.07b709db.png\"},222:function(e,t,v){e.exports=v.p+\"assets/img/addMatchingMappings.dad3e33d.png\"},223:function(e,t,v){e.exports=v.p+\"assets/img/getHandlerExecutionChain.c5bc6427.png\"},224:function(e,t,v){e.exports=v.p+\"assets/img/notFound.cecc4f93.png\"},225:function(e,t,v){e.exports=v.p+\"assets/img/getHandlerAdapter.51b8cf5d.png\"},226:function(e,t,v){e.exports=v.p+\"assets/img/invoke-handler.79580e1b.png\"},227:function(e,t,v){e.exports=v.p+\"assets/img/doInvoke.9e466682.png\"},243:function(e,t,v){\"use strict\";v.r(t);var r=v(0),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"springmvc\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#springmvc\"}},[e._v(\"#\")]),e._v(\" SpringMVC\")]),e._v(\" \"),r(\"h2\",{attrs:{id:\"一、springmvc如何对请求进行解析？\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一、springmvc如何对请求进行解析？\"}},[e._v(\"#\")]),e._v(\" 一、SpringMVC如何对请求进行解析？\")]),e._v(\" \"),r(\"p\",[e._v(\"在SpringMVC中一个请求最终是由\"),r(\"code\",[e._v(\"servlet\")]),e._v(\"接口中的\"),r(\"code\",[e._v(\"service\")]),e._v(\"方法解析，从流程图上看，这个\"),r(\"code\",[e._v(\"dispatcherServlet\")]),e._v(\"就是\"),r(\"code\",[e._v(\"servlet\")]),e._v(\"的实现类\\n但该类并未直接实现\"),r(\"code\",[e._v(\"servlet\")]),e._v(\"接口，而是通过多次继承间接了的实现了接口，其实现关系为\")]),e._v(\" \"),r(\"p\",[r(\"strong\",[e._v(\"DispatcherServlet --\\x3e FrameworkServlet --\\x3e HttpServletBean --\\x3e HttpServlet --\\x3e GenericServlet\")]),e._v(\"，而\"),r(\"code\",[e._v(\"GenericServlet\")]),e._v(\"最终实现了\"),r(\"code\",[e._v(\"Servlet\")]),e._v(\"接口\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(214),alt:\"\"}}),e._v(\"\\n由于我们已经知道处理请求的关键是\"),r(\"code\",[e._v(\"Servlet\")]),e._v(\"中的\"),r(\"code\",[e._v(\"service\")]),e._v(\"方法，因此我们直接去找这个方法，可以看到这个方法最后一次复写是在\"),r(\"code\",[e._v(\"HttpServlet\")]),e._v(\"类中（注意\"),r(\"code\",[e._v(\"Servlet\")]),e._v(\"中的\"),r(\"code\",[e._v(\"service\")]),e._v(\"方法参数是\"),r(\"code\",[e._v(\"ServletRequest\")]),e._v(\"和\"),r(\"code\",[e._v(\"ServletRequest\")]),e._v(\"类型）\")]),e._v(\" \"),r(\"p\",[e._v(\"在这个方法里Spring并没有对请求真正进行处理，只是将参数的类型强转成了\"),r(\"code\",[e._v(\"HttpServletRequest\")]),e._v(\"、\"),r(\"code\",[e._v(\"HttpServletResponse\")]),e._v(\"类型\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(215),alt:\"\"}}),e._v(\"\\n然后继续调用\"),r(\"code\",[e._v(\"service(httpServletRequest, httpServletResponse)\")]),e._v(\"方法，由于在\"),r(\"code\",[e._v(\"FrameworkServlet\")]),e._v(\"复写了该方法，因此优先调用子类中的方法，在子类中只做了一件事，判断是否是\"),r(\"code\",[e._v(\"patch\")]),e._v(\"类型的请求。\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(216),alt:\"\"}}),e._v(\"\\n若是，则不调用父类方法，直接开始解析请求，由于在debugger时是一个get请求，因此在这里调用了父类中的方法\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(217),alt:\"\"}}),e._v(\"\\n在父类中的对请求类型进行了判断，如果是\"),r(\"code\",[e._v(\"post\")]),e._v(\"、\"),r(\"code\",[e._v(\"put\")]),e._v(\"、\"),r(\"code\",[e._v(\"delete\")]),e._v(\"则不作其他逻辑判断，直接调用\"),r(\"code\",[e._v(\"doPost\")]),e._v(\"方法即可，如果是\"),r(\"code\",[e._v(\"get\")]),e._v(\"请求，则通过判断\"),r(\"code\",[e._v(\"http\")]),e._v(\"中的\"),r(\"code\",[e._v(\"if-modified-since\")]),e._v(\"属性来决定是否对请求进行处理\")]),e._v(\" \"),r(\"blockquote\",[r(\"p\",[e._v(\"在http中Last-Modified 与If-Modified-Since 都是用于记录页面最后修改时间的 HTTP 头信息。\\n注意,在这 Last-Modified 是由服务器往客户端发送的 HTTP 头，另一个 If-Modified-Since是由客户端往服务器发送的头。\\n再次请求本地存在的 cache 页面时，客户端会通过 If-Modified-Since 头将先前服务器端发过来的 Last-Modified 最后修改时间戳发送回去。\\n这是为了让服务器端进行验证，通过这个时间戳判断客户端的页面是否是最新的，如果不是最新的，则返回新的内容，如果是最新的，则 返回 304 告诉客户端其本地 cache 的页面是最新的，于是客户端就可以直接从本地加载页面了。\\n这样在网络上传输的数据就会大大减少，同时也减轻了服务器的负担。\")])]),e._v(\" \"),r(\"p\",[e._v(\"判断后调用\"),r(\"code\",[e._v(\"FrameworkServlet\")]),e._v(\"的\"),r(\"code\",[e._v(\"doGat\")]),e._v(\"方法，在这个方法中只有一句话\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(218),alt:\"\"}}),e._v(\"\\n点进去继续看，在这个方法中，初始化了一些属性值这里我们不过多关注，只看主流程，真正处理请求的是\"),r(\"code\",[e._v(\"doService(request, response)\")]),e._v(\"方法\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(219),alt:\"\"}}),e._v(\"\\n而在\"),r(\"code\",[e._v(\"doService\")]),e._v(\"中我们发现真正对请求进行处理的是\"),r(\"code\",[e._v(\"doDispatch(request, response)\")]),e._v(\"方法\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(220),alt:\"\"}}),e._v(\"\\n从名称上看开始对请求进行分发了，其中两个方法比较关键，一个是\"),r(\"code\",[e._v(\"getHandler\")]),e._v(\"，获取当前的请求的处理器，一个是获取处理器对应的适配器\")]),e._v(\" \"),r(\"p\",[e._v(\"我们先来看是如何获取的Handler的，在\"),r(\"code\",[e._v(\"getHandler\")]),e._v(\"方法中，将遍历已经初始化好的handlerMapping\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(221),alt:\"\"}}),e._v(\"\\n在这里面有一个\"),r(\"code\",[e._v(\"RequestMappingHandlerMapping\")]),e._v(\"，这个就是实际负责将带有\"),r(\"code\",[e._v(\"@RequestMapping\")]),e._v(\"注解的方法，添加到这个映射关系中去\")]),e._v(\" \"),r(\"p\",[r(\"code\",[e._v(\"mapping.getHandler\")]),e._v(\"在这个方法中，通过往下调用，最终会调用到\"),r(\"code\",[e._v(\"AbstractHandlerMethodMapping\")]),e._v(\"这个类中的\"),r(\"code\",[e._v(\"addMatchingMappings\")]),e._v(\"方法\\n通过debugger可以看到，Spring将所有的URL映射关系全部放入一个map中，在这个方法中将当前请求路径对应的bean拿到\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(222),alt:\"\"}}),e._v(\"\\n拿到bean后，我们返回到\"),r(\"code\",[e._v(\"getHandler\")]),e._v(\"方法，继续往下走，发现这个方法\"),r(\"code\",[e._v(\"getHandlerExecutionChain\")]),e._v(\"返回了一个\"),r(\"code\",[e._v(\"HandlerExecutionChain\")]),e._v(\"，在这个方法中，只做了一件事，就是找到这个URL匹配的拦截器\\n将其放入处理器执行链，其由\"),r(\"code\",[e._v(\"controller\")]),e._v(\"和拦截器组成\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(223),alt:\"\"}}),e._v(\"\\n在拿到这个处理器执行链后，\"),r(\"code\",[e._v(\"getHandler\")]),e._v(\"方法可以基本完成了他的使命，返回到\"),r(\"code\",[e._v(\"DisPatcherServlet\")]),e._v(\"中\\n代码继续往下走，这里可以看到如果没有拿到对应的处理器，则这个请求开始返回404\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(224),alt:\"\"}}),e._v(\"\\n接下来我们在关注\"),r(\"code\",[e._v(\"getHandlerAdapter\")]),e._v(\"这个方法，这个方法是获取处理器对应的适配器，在这个方法中依旧遍历已经初始化好的适配器，显然这里使用\"),r(\"code\",[e._v(\"RequestMappingHandlerAdapter\")])]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(225),alt:\"\"}}),e._v(\"\\n在拿到适配器后程序继续向下走，直到看到这样一段代码，这里显然开始真正执行请求了\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(226),alt:\"\"}}),e._v(\"\\n在这个方法中通过一层一层调用最终执行到这样一个方法，在这里进行反射调用，执行了最终\"),r(\"code\",[e._v(\"controller\")]),e._v(\"方法，我们定义的\"),r(\"code\",[e._v(\"controller\")]),e._v(\"流程执行完了\")]),e._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:v(227),alt:\"\"}}),e._v(\"\\n最后通过\"),r(\"code\",[e._v(\"mappedHandler.triggerAfterCompletion()\")]),e._v(\"方法完成拦截器中的\"),r(\"code\",[e._v(\"afterCompletion\")]),e._v(\"方法\")])])}),[],!1,null,null,null);t.default=s.exports}}]);","extractedComments":[]}